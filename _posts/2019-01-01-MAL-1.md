---
layout: post
title: "Make a Lisp [1] - 2019 New Year's resolution"
date: 2019-01-01
---

# A New Year's resolution for 2019: Make a Lisp

Lisp first appeared in 1958, one of four  programming languages (the others being FORTRAN, COBOL and Algol) that transformed the nascent computer industry. I recently decided to reinvigorate my ancient knowledge of computer science by attempting to create my very own modern version of Lisp. To do this, I have to understand the computing concepts that underlie a language like Lisp, and be able to implement them in a suitable software development environment.

I'm making the completion of this project a resolution for 2019.

# Making a Lisp

I'm not starting this project from a completely clean state. Specifically, I'm following a step-by-step process taken from the [Make a Lisp](https://github.com/kanaka/mal) website developed by Joel Martin. If you follow the nine steps, you end up with software (an interpreter) that can interactively read and process statements in `Mal`, Joel's Lisp-like language.

You might think that simply following someone else's instructions is cheating. However, the instructions assume a working knowledge of programming, and don't include sample code that you can simply copy and paste. For example, here is the first instruction of the first step:

*"Add the 4 trivial functions READ, EVAL, PRINT, and rep (read-eval-print). READ, EVAL, and PRINT are basically just stubs that return their first parameter (a string if your target language is a statically typed) and rep calls them in order passing the return to the input of the next."*

Successive instructions describe more complex tasks, ending up with the somewhat mind-bending concept of making the `Mal` interpreter sufficiently powerful that it can self-host, that is, run a copy of itself.

I've chosen [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)) as my implementation language, largely because it's so similar to the languages that I used back when I was actually paid to write software. I know that creating `Mal` in C# is doable, because Joel's website includes the full source code of a C# `Mal` interpreter, along with `Mal`s written in approximately 70 other programming languages. However, I'm going to try to avoid looking at this reference implementation, figuring out what the instructions mean on my own, without building on the work of the open source enthusiasts that have gone down this path before me. If something completely defeats me, I'll allow myself to look at one of the non-C# implementations for guidance.

In future posts in this series, I'll describe the process that I'm making as I work toward completing this task. Just to finish off though, I'll admit that another reason for calling this a resolution (rather than just another side project) is that I've previously tried and failed to complete it. A couple of years ago, I tried to Make a Lisp using the [Clojure](https://en.wikipedia.org/wiki/Clojure) programming language. Clojure and its tooling (the EMACS editor / run-time) were simply too unfamiliar to me, and I gave up somewhere in the middle of the second step.
