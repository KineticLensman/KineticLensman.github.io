---
layout: post
title: "Make a Lisp [2] SITREP"
date: 2019-01-21
---

# Make a Lisp - Tech SITREP

Today, approximately five weeks after starting this project, I've got a Lisp sophisticated enough to read and evaluate functions that are halfway useful. Exhibit A:

`(def factorial (fn (n) (if (<= n 1) n (* n (factorial (- n 1))))))`

Taking this from the left:

* `(def factorial ...)` - define a symbol called `factorial` and assign to it the result of ...
* `(fn (n) ...)` creating a function that takes a single argument `n` and whose value depends on the result of evaluating the boolean expression...
* `(<= n 1)`. If this is true, the result is `n`. Otherwise, the result is calculated by
* recursively invoking `factorial` on `(- n 1)`.

To get to this point, I've completed steps 1 to 4 in the Mal guide I'm following. I cheated slightly by looking at the reference C# implementation ('C#-Mal'), specifically to understand how to
* Use the C# regular expression mechanism to scan the input and convert it into tokens (i.e. `(`, `def`, `factorial`, `(`, etc)
* Implement Mal types (symbol, list, number, string, etc) using C# classes
* Create closures (nameless functions that can be created, associated with Lisp symbols and subsequently invoked).

But the rest I figured out on my own based on the instructions in the guide. In my defence, I've also made some improvements. Specifically, JKL can handle:

* Floating point numbers such as: `1.2`, `.5`, `-.5` whereas Mal can only handle integers (once I'd figured out how it worked, I wrote a more comprehensive regex handler than C#-Mal's)
* A wider range of errors without crashing back into the C# debugger
* Multi-line forms (`(READ...)` is invoked until the input line is empty; in Mal it's called once per line)
* Multi-form lines (`(READ...)` uses a queue of tokens that is refilled if the tokens run out in the middle of a list, vector or hashmap)
* Arithmetic operations (`+`, `-`, `*` and `\`)that have more than two arguments

Additionally some of the code is less verbose than C#-Mal because I'm using a later version of C#.

Now that I'm on a roll, I *think* I can avoid further cheating by looking at reference C#-Mal. We'll see when I get to step 5, which involves some quite complex internal changes (so-called tail-call optimisation) to avoid internal stack overflows when functions such as `factorial` recurse a lot.
